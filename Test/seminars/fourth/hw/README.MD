Задание 1. Ответьте письменно на вопросы:

1)  Почему использование тестовых заглушек может быть полезным при написании модульных тестов?

Использование тестовых заглушек может быть полезным при написании модульных тестов по нескольким причинам:
Изоляция зависимостей: Тестовые заглушки позволяют изолировать модуль, который мы хотим протестировать, от его зависимостей. Это позволяет нам сосредоточиться на тестировании конкретного модуля, не беспокоясь о правильности работы его зависимостей.
Контроль состояния: Тестовые заглушки позволяют нам контролировать состояние и поведение зависимостей модуля во время тестирования. Мы можем настроить заглушку таким образом, чтобы она возвращала определенные значения или генерировала исключения, чтобы проверить различные сценарии работы модуля.
Ускорение тестирования: Заглушки могут быть более быстрыми и легкими в использовании, чем реальные зависимости. Это позволяет нам ускорить процесс тестирования и повысить производительность наших модульных тестов.
Изоляция от внешних факторов: Использование заглушек позволяет нам изолировать модуль от внешних факторов, таких как сетевые запросы или доступ к базе данных. Это делает тестирование более надежным и предсказуемым.
В целом, использование тестовых заглушек помогает нам создавать более надежные, изолированные и быстрые модульные тесты, что в свою очередь способствует повышению качества нашего кода.

2) Какой тип тестовой заглушки следует использовать, если вам нужно проверить, что метод был вызван с определенными
аргументами?

Если нужно проверить, что метод был вызван с определенными аргументами, следует использовать мок-объекты (mock objects).
Мок-объекты - это специальные объекты, которые создаются для замены реальных зависимостей в модуле, который мы хотим протестировать. Мок-объекты позволяют нам записывать информацию о вызовах методов и аргументах, с которыми они были вызваны. Затем мы можем проверить эту информацию в наших тестах, чтобы убедиться, что метод был вызван с ожидаемыми аргументами.

```java
// Создание мок-объекта
BookRepository bookRepositoryMock = Mockito.mock(BookRepository.class);

// Настройка поведения мок-объекта
Mockito.when(bookRepositoryMock.getBookById(1)).thenReturn(new Book("1234567890", "Test Book"));

// Вызов метода, который использует зависимость bookRepository
BookService bookService = new BookService(bookRepositoryMock);
bookService.getBookById(1);

// Проверка, что метод был вызван с определенными аргументами
Mockito.verify(bookRepositoryMock).getBookById(1);

```
В этом примере мы создаем мок-объект bookRepositoryMock для интерфейса BookRepository. Затем мы настраиваем его поведение с помощью метода thenReturn, чтобы он возвращал определенную книгу при вызове метода getBookById с аргументом 1. Затем мы вызываем метод getBookById в BookService и затем проверяем, что метод getBookById был вызван с аргументом 1 с помощью метода verify.
Таким образом, использование мок-объектов позволяет нам проверить, что метод был вызван с определенными аргументами в наших модульных тестах.

3) Какой тип тестовой заглушки следует использовать, если вам просто нужно вернуть определенное значение или исключение 
в ответ на вызов метода?

Если просто нужно вернуть определенное значение или исключение в ответ на вызов метода, следует использовать заглушки (stubs).
Заглушки - это объекты, которые заменяют реальные зависимости в модуле, который мы хотим протестировать. Они позволяют нам контролировать поведение методов и возвращать определенные значения или генерировать исключения при вызове.

```java
// Создание заглушки
BookRepository bookRepositoryStub = new BookRepositoryStub();

// Настройка поведения заглушки
bookRepositoryStub.setBook(new Book("1234567890", "Test Book"));

// Вызов метода, который использует зависимость bookRepository
BookService bookService = new BookService(bookRepositoryStub);
Book book = bookService.getBookById(1);

// Проверка возвращенного значения
assertEquals("1234567890", book.getId());
assertEquals("Test Book", book.getTitle());

```
В этом примере мы создаем заглушку bookRepositoryStub, которая реализует интерфейс BookRepository. Затем мы настраиваем ее поведение с помощью метода setBook, чтобы она возвращала определенную книгу при вызове метода getBookById. Затем мы вызываем метод getBookById в BookService и проверяем возвращенное значение с помощью метода assertEquals.
Таким образом, использование заглушек позволяет нам вернуть определенное значение или исключение в ответ на вызов метода в наших модульных тестах.

4) Какой тип тестовой заглушки вы бы использовали для имитации  взаимодействия с внешним API или базой данных?

Для имитации взаимодействия с внешним API или базой данных рекомендуется использовать фейковые объекты (fake objects) или тестовые двойники (test doubles), такие как фейковые API-клиенты или фейковые базы данных.
Фейковые объекты - это специальные объекты, которые имитируют поведение реальных зависимостей, но без реального взаимодействия с внешними системами. Они позволяют нам создавать контролируемую среду для тестирования, где мы можем имитировать различные сценарии и ответы от внешних систем.

```java
// Создание фейкового API-клиента
ApiService apiServiceFake = new ApiServiceFake();

// Настройка поведения фейкового API-клиента
apiServiceFake.setResponse(new ApiResponse(200, "Success"));

// Вызов метода, который использует зависимость apiService
UserService userService = new UserService(apiServiceFake);
User user = userService.getUserById(1);

// Проверка возвращенного значения
assertEquals("John Doe", user.getName());
```

В этом примере мы создаем фейковый API-клиент apiServiceFake, который реализует интерфейс ApiService. Затем мы настраиваем его поведение с помощью метода setResponse, чтобы он возвращал определенный ответ при вызове метода getUserById. Затем мы вызываем метод getUserById в UserService и проверяем возвращенное значение с помощью метода assertEquals.
Аналогично, для имитации взаимодействия с базой данных, вы можете создать фейковую базу данных, которая будет имитировать операции чтения и записи данных без реального взаимодействия с реальной базой данных.
Таким образом, использование фейковых объектов позволяет нам имитировать взаимодействие с внешними системами и создавать контролируемую среду для тестирования в наших модульных тестах.

Задание 2.

У вас есть класс BookService, который использует интерфейс BookRepository для получения информации о книгах из 
базы данных. Ваша задача написать unit-тесты для BookService, используя Mockito для создания мок-объекта BookRepository.

Формат сдачи: воспользуйтесь одним из вариантов: Ссылка на репозиторий Git или Прикрепленный архив

Письменное задание 1 можно также разместить в репозитории или разместить текстом в окне сдачи практического задания.